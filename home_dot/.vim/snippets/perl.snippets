snippet #!
	#!/usr/bin/env perl
	use strict;
	use warnings;
	use autodie;
	use feature qw(say);

	${0}
snippet #!s
	#!/usr/bin/perl
	use strict;
	use warnings;
	use autodie;
	use feature qw(say);

	${0}
snippet #!m
	#!/usr/bin/env perl
	use Mojolicious::Lite;

	${0}
snippet utf8
	use utf8;
	binmode STDIN,  ':utf8';
	binmode STDOUT, ':utf8';
	binmode STDERR, ':utf8';
	${0}
snippet utf8e
	use utf8;
	binmode STDIN,  ':encoding(utf8)';
	binmode STDOUT, ':encoding(utf8)';
	binmode STDERR, ':encoding(utf8)';
	${0}
snippet usage
	=head1 SYNOPSIS

		# all strategies
		> perl foo.pl --dir kl_div *.csv

		foo.pl [options] FILES

		Options:
		--help  brief help message
		--dir   output directory    (required)

	=head1 DESCRIPTION

		make files

	=cut

	use Getopt::Long qw(:config auto_help no_ignore_case);
	use Pod::Usage;

	GetOptions(
		\my %opt, qw(dir=s)
	) or pod2usage(1);

	for my $x (qw(dir)) {
		if (!exists $opt{$x}) {
			die 'set --' . $x . "\n";
		}
	}
	${0}
snippet any
	sub any (&@) {
		my $func = shift;
		for (@_) {
			if ($func->()) {
				return 1;
			}
		}
		0;
	}
	${0}
snippet all
	sub all (&@) {
		my $func = shift;
		for (@_) {
			if (!$func->()) {
				return 0;
			}
		}
		1;
	}
	${0}
snippet none
	sub none (&@) {
		my $func = shift;
		for (@_) {
			if ($func->()) {
				return 0;
			}
		}
		1;
	}
	${0}
snippet uniq
	sub uniq {
		my ($lst) = @_;
		my %seen;
		@$lst = grep { ++$seen{$_} == 1 } @$lst;
		$lst;
	}
	${0}
snippet union
	sub union {
		my ($x, $y) = @_;
		my %cnt;
		[ grep { ++$cnt{$_} == 1 } (@$x, @$y) ];
	}
	${0}
snippet intersection
	sub intersection {
		my ($x, $y) = @_;
		my %cnt;
		[ grep { ++$cnt{$_} == 2 } (@{&uniq($x)}, @{&uniq($y)}) ];
	}
	${0}
snippet difference
	sub difference {
		my ($x, $y) = @_;
		my %cnt;
		map { $cnt{$_} = -1 } @$y;
		[ grep { ++$cnt{$_} == 1 } @{&uniq($x)} ];
	}
	${0}
snippet zip
	sub zip {
		my @args = @_;
		my $ret;
		for (;;) {
			my @xs = map { shift @$_ } @args;
			for (@xs) {
				if (!defined $_) {
					return $ret;
				}
			}
			push @$ret, [@xs];
		}
	}
	${0}
snippet dup
	sub dup {
		my ($lst) = @_;
		my %seen;
		@$lst = grep { ++$seen{$_} == 2 } @$lst;
		$lst;
	}
	${0}
snippet readfile
	sub read_file {
		with_file($_[0], '<', sub {
			my ($hdl) = @_;
			chomp(my @ret = <$hdl>);
			\@ret;
		});
	}
	${0}
snippet withfile
	sub with_file {
		my ($file, $mode, $func) = @_;
		open(my $fh, $mode, $file);
		my $ret = $func->($fh);
		close $fh;
		$ret;
	}
	${0}
snippet withinput
	sub with_input_from_file {
		my ($path, $func) = @_;
		open(my $tmp, '<&', \*STDIN);
		open(STDIN, '<', $path);
		my $ret = $func->();
		close STDIN;
		open(STDIN, '<&', $tmp);
		close $tmp;
		$ret;
	}
	${0}
snippet withoutput
	sub with_output_to_file {
		my ($path, $func) = @_;
		open(my $tmp, '>&', \*STDOUT);
		open(STDOUT, '>', $path);
		my $ret = $func->();
		close STDOUT;
		open(STDOUT, '>&', $tmp);
		close $tmp;
		$ret;
	}
	${0}
snippet dirlist
	sub dir_list {
		my ($dir) = @_;
		opendir(my $dh, $dir);
		my $ret = [ readdir $dh ];
		closedir $dh;
		$ret;
	}
	${0}
snippet mktemp
	sub mktemp {
		my ($func) = @_;
		my ($fh, $filename) = tempfile();
		$func->($fh);
		close $fh;
		$filename;
	}
	${0}
snippet withdb
	sub with_db {
		my ($db, $func) = @_;
		my $dbh = DBI->connect("dbi:SQLite:dbname=$db", undef, undef,
		                      { AutoCommit => 0, RaiseError => 1,
		                        sqlite_unicode => 1 });
		my $ret = $func->($dbh);
		$dbh->disconnect;
		$ret;
	}
	${0}
snippet p
	use Data::Dumper;
	$Data::Dumper::Sortkeys = 1;
	sub p { print Dumper $_[0] }
	${0}
# useful settings
snippet min
	sub min {
		my ($ns) = @_;
		my $ret = $ns->[0];
		for my $i (1 .. $#$ns) {
			if ($ret > $ns->[$i]) {
				$ret = $ns->[$i];
			}
		}
		$ret;
	}
	${0}
snippet max
	sub max {
		my ($ns) = @_;
		my $ret = $ns->[0];
		for my $i (1 .. $#$ns) {
			if ($ret < $ns->[$i]) {
				$ret = $ns->[$i];
			}
		}
		$ret;
	}
	${0}
snippet bins
	sub bin_search {
		my ($lst, $x) = @_;
		my $l = 0;
		my $r = @$lst;
		while ($r - $l >= 1) {
			my $m = int(($l+$r)/2);
			if ($lst->[$m] == $x) {
				return 1;
			} elsif ($lst->[$m] < $x) {
				$l = $m + 1;
			} else {
				$r = $m;
			}
		}
		0;
	}
	${0}
snippet whl
	while (my $l = <>) {
		chomp $l;
		${0}
	}
snippet onl
	chomp(my $l = <>);
snippet buf
	select((select($hdl), $|=1)[0]);
	${0}
snippet ipv4
	my $ipv4_rx = qr(^(?:(?:[1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}(?:[1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$);
	${0}
snippet ipv4zeropedding
	my $ipv4_rx_zero_padding = qr(^(?:(?:[01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}(?:[01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])$);
	${0}
snippet bench
	use Benchmark qw(timethese cmpthese);

	sub timethese_report {
		my ($how, $alist) = @_;
		my $rslt = timethese($how, $alist);
		cmpthese($rslt);
	}

	timethese_report(-10, { f1 => sub { foo(\@lst) }, f2 => sub { bar(\@lst) }});
	${0}
